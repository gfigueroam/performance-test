def app_name = "uds"
def docker_folder = "com-hmhco-uds"

// UDS service is built on Node and requiring at least version 6.3.0
// Jenkins needs a base HMH Node container to build and test UDS service
//  Docker-in-Docker causes permission issues for the host user inside the container
//  Use volumes to give container access to user info and permissions to home directory
def node_version = "10-latest"

// Unique name for this pipeline used to target running docker containers
def docker_bvt_container_id
// sem_version + git_commit used to identify image on bedrock artifactory
def docker_tag
// series of names used to identify the runtime image being built
def docker_runtime_registry_relative_name
def docker_runtime_registry_absolute_name
def docker_runtime_registry_absolute_tagged_name

// Image used for local bvts
def docker_dynamodb_image_name = "docker.br.hmheng.io/com-hmhco-uds/dynamodb:latest"

// Bifrost build image which is used to perform builds and run tests, has
// common build dependencies such as python, git installed
def docker_build_image_name = "docker.br.hmheng.io/com-hmhco-csl/bifrost-build-env:${node_version}"
def docker_build_image_params = "--privileged -v /etc/passwd:/etc/passwd -v /home/ec2-user:/home/ec2-user"

// Source controlled docker files used to create runtimes
def docker_runtime_dockerfile = "Dockerfile"
def docker_perftest_dockerfile = "perftest.Dockerfile"

// GUID for 'hmheng-ci' Credentials configured on Jenkins instance (devel + prod)
def ssh_agent_git_credentials = "66427afc-2571-4f67-b135-c9a4e6b50ca2"

def git_commit
def jenkins_env
def sem_version
def package_version

node {
  try {
    stage("Checkout") {
      checkout scm
      sh "git log -1"

      git_commit = find_git_commit()
      echo "Git Commit -> $git_commit"

      docker_bvt_container_id = "$git_commit-${env.JOB_BASE_NAME}"
      echo "Docker ID -> $docker_bvt_container_id"

      package_version = find_package_version()
      echo "Package Version -> $package_version"

      sem_version = "$package_version-${env.BUILD_NUMBER}"
      echo "Semantic Version -> $sem_version"

      docker_tag = "$sem_version-$git_commit"
      echo "Docker Tag -> $docker_tag"

      docker_runtime_registry_relative_name = "$docker_folder/$app_name"
      docker_runtime_registry_absolute_name = "docker.br.hmheng.io/$docker_runtime_registry_relative_name"
      docker_runtime_registry_absolute_tagged_name = "$docker_runtime_registry_absolute_name:$docker_tag"
      echo "Generated Docker Registry Name -> $docker_runtime_registry_relative_name"
      echo "Generated Docker Registry Absolute Name -> $docker_runtime_registry_absolute_name"
      echo "Generated Docker Registry Absolute Name with Tag -> $docker_runtime_registry_absolute_tagged_name"

      // Jenkins builds are parameterized with Jenkins env (devel/prod)
      jenkins_env = env.JENKINS_ENV
      if (jenkins_env == null) {
        jenkins_env = "devel"
      }
      echo "Jenkins Environment -> $jenkins_env"

      // Capture the version information for Jenkins build identifier
      currentBuild.displayName = "$sem_version"

      // Publish a message to Slack channel that build pipeline is starting
      def start_message = "Starting deploy of UDS version: $docker_tag"
      publish_status_message(start_message, "good", jenkins_env)
    }

    // build app and run unit test locally
    // app_deploy folder will get populated
    // all code for deployment will now be on the volume
    docker.image(docker_build_image_name).inside(docker_build_image_params) {
      stage("Build + Test") {
        sshagent([ssh_agent_git_credentials]) {
          sh "npm run build:app"
        }
        sh "npm test"
      }
    }

    // we need the coverage generated by the tests to run the code quality analysis.
    if (!jenkins_env.equalsIgnoreCase("prod")) {
      sonarqube_analysis()
    }

    // build Image using Dockerfile
    // adds app_deploy folder into image that was created earlier
    // if -p param then push to artifactory
    stage("Build Docker Images") {
      if (jenkins_env.equalsIgnoreCase("prod")) {
        echo "Building Docker container in Jenkins production and pushing to HMH Artifactory"
        sh "builder build -p $docker_runtime_registry_relative_name $docker_tag -f $docker_runtime_dockerfile"
      } else {
        echo "Building Docker container locally in non-production Jenkins environment: $jenkins_env"
        sh "builder build $docker_runtime_registry_relative_name $docker_tag -f $docker_runtime_dockerfile"
      }
    }

    stage("Launch BVT Docker Containers") {
      // Setup
      sh "docker ps"
      stop_docker_containers(docker_bvt_container_id)

      def dynamoDB
      def udsService
      def dbCreate

      try {
        // Run DynamoDB instance
        dynamoDB = docker
          .image(docker_dynamodb_image_name)
          .run("--name dynamodb-$docker_bvt_container_id -d")
        sh "sleep 10" // Give DynamoDB some startup breathing room. If this goes by too quickly UDS will fail to connect

        // Run UDS service instance
        udsService = docker
          .image(docker_runtime_registry_absolute_tagged_name)
          .run("--name uds-$docker_bvt_container_id -e NODE_ENV=docker --link dynamodb-$docker_bvt_container_id:dynamodb -d", "npm run start-transpiled")
        sh "sleep 10" // Give UDS a moment to start up before executing

        sh "docker ps"
        sh "docker logs uds-$docker_bvt_container_id"
        sh "docker logs dynamodb-$docker_bvt_container_id"

        // Run Create DynamoDB Tables instance
        dbCreate = docker
          .image(docker_build_image_name)
          .run("--name db-create-$docker_bvt_container_id --link dynamodb-$docker_bvt_container_id:dynamodb -d -v \"${WORKSPACE}\":/opt/uds -w=/opt/uds", "npm run db:create:docker")
        sh "sleep 20" // Give the database creation script a moment to complete
        sh "docker logs db-create-$docker_bvt_container_id"

        // Use the bifrost build image to run the BVT mocha tests without transpiling
        docker
          .image(docker_build_image_name)
          .inside("--link uds-$docker_bvt_container_id:uds --link dynamodb-$docker_bvt_container_id:dynamodb $docker_build_image_params") {
            stage("Run BVT: docker") {
              sh "npm run bvt:docker"
            }
          }
        sh "docker logs uds-$docker_bvt_container_id"
      }
      catch (Exception e) {
        // Leaving the catch/throw to make it explicit that if there is an
        // error the error will be thrown but always finally is executed
        throw e;
      }
      finally {
        if (dynamoDB) {
          dynamoDB.stop()
        }

        if (udsService) {
          udsService.stop()
        }

        if (dbCreate) {
          dbCreate.stop()
        }
      }
    }

    if (jenkins_env.equalsIgnoreCase("prod")) {
      deploy_container(app_name, docker_tag, "dev")
      run_bvt("dev", docker_build_image_name, docker_build_image_params)

      deploy_container(app_name, docker_tag, "int")
      run_bvt("int", docker_build_image_name, docker_build_image_params)

      deploy_container(app_name, docker_tag, "cert")
      run_bvt("cert", docker_build_image_name, docker_build_image_params)

      run_perf("cert", docker_runtime_registry_relative_name, docker_build_image_params, docker_perftest_dockerfile, "$docker_tag-perf")

      deploy_container(app_name, docker_tag, "prod")
      run_bvt("prod", docker_build_image_name, docker_build_image_params)
    } else {
      echo "Skipping deploy and BVT stages in non-production Jenkins environment: $jenkins_env"
    }

    stop_docker_containers(docker_bvt_container_id)

    def result_message = "Successfully deployed UDS version: $docker_tag"
    publish_status_message(result_message, "good", jenkins_env)
  } catch (error) {
    // output the error to the jenkins console to help debug
    echo error
    currentBuild.result = "FAILURE"

    def failure_message = "Error deploying UDS version: $docker_tag"
    publish_status_message(failure_message, "danger", jenkins_env)

    stop_docker_containers(docker_bvt_container_id)

    // After sending Slack message, throw the error to fail the build
    throw error
  }
}

def stop_docker_containers(String docker_bvt_container_id) {
  // Stop Docker containers
  sh "docker stop db-create-$docker_bvt_container_id || true"
  sh "docker stop dynamodb-$docker_bvt_container_id || true"
  sh "docker stop uds-$docker_bvt_container_id || true"
  sh "docker rm db-create-$docker_bvt_container_id || true"
  sh "docker rm dynamodb-$docker_bvt_container_id || true"
  sh "docker rm uds-$docker_bvt_container_id || true"
}

def find_git_commit() {
  sh "git rev-parse HEAD > commit"
  return readFile("commit").trim()
}

def find_package_version() {
  sh "cat package.json | grep version | head -1 | awk -F: '{ print \$2 }' | sed 's/[\",]//g' | tr -d '[[:space:]]' > package_version"
  return readFile("package_version").trim()
}

def deploy_container(String app, String tag, String deploy_env) {
  // Deploy UDS container with latest 'tag' to target 'deploy_env'
  stage("Deploy Environment: $deploy_env") {
    def role = "hmheng-uds"
    def aurora_filename = "deploy/bedrock/aurora/app.aurora"
    def ssh_agent_deploy_credentials = "hmheng-uds" // From Jenkins instance

    sshagent([ssh_agent_deploy_credentials]) {
      sh "builder deploy -f $aurora_filename $role $app $tag $deploy_env"
    }
  }
}

def run_perf(String deploy_env, String image_name, String docker_params, String dockerfile, String tag) {
  stage("Build perf test image") {
    echo "Building Docker image for perf testing" // installs utils for test such as scala, openjdk, sbt
    sh "builder build $image_name $tag -f $dockerfile"
  }
  // Launch containing docker image and run suite of Perfomance Tests for given environment
  docker.image("docker.br.hmheng.io/$image_name:$tag").inside(docker_params) {
    stage("Run Perfomance: $deploy_env") {
        sh "export NODE_ENV='$deploy_env' && ./test/perf/scripts/gatling_test.sh"
    }
  }
}

def run_bvt(String deploy_env, String image_name, String docker_params) {
  // Launch containing docker image and run suite of BVTs for given environment
  docker.image(image_name).inside(docker_params) {
    stage("Run BVT: $deploy_env") {
      sh "npm run bvt:$deploy_env"
    }
  }
}

def publish_status_message(String status_message, String status_color, String build_env) {
  // Send status 'message' content to Slack with good/warning/danger 'color'
  if (build_env.equalsIgnoreCase("prod")) {
    slackSend color: status_color, message: status_message
  } else {
    echo "Skipping Slack message in non-production Jenkins environment: $build_env"
  }
}

def sonarqube_analysis() {
  stage('Code analysis') {
    // requires SonarQube Scanner 2.8+
    def scannerHome = tool 'sonarqube_scanner';
    withSonarQubeEnv('SonarQubeServer') {
      sh "${scannerHome}/bin/sonar-scanner"
    }
    timeout(time: 1, unit: 'HOURS') {
      // For this to work correctly the Jenkins CI url must be entered in
      // SonarQube -> Administration -> Configuration -> Webhooks
      waitForQualityGate abortPipeline: true
    }
  }
}

