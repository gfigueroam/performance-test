import errors from '../../models/errors';
import regex from '../utils/regex';
import system from '../../models/system';

const NONEMPTY_MIN_LENGTH = 1;
const DEFAULT_MAX_LENGTH = 255;

// Helper function to validate a string against a specific regex
function validRegex(value, regexString, errorCode) {
  const requiredRegex = new RegExp(regexString);
  if (requiredRegex.test(value) === false) {
    throw errorCode;
  }
}

// Helper function to validate string length is greater/equal to some min
function validMinLength(value, length, errorCode) {
  if (value.length < length) {
    throw errorCode;
  }
}

// Helper function to validate string length is less/equal to some max
function validMaxLength(value, length, errorCode) {
  if (value.length > length) {
    throw errorCode;
  }
}


// Validate incoming `param` is a string and valid setting name
//  Setting names have a strict regex of allowed characters
function validateName(param) {
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_NAME,
  );
  validRegex(
    param,
    `^${regex.NAME_REGEX}$`,
    errors.codes.ERROR_CODE_INVALID_NAME,
  );
}

function validatePassword(param) {
  // Check that password is a non-empty string
  //  Handler will validate whether password is correct
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_PASSWORD,
  );
  validMinLength(
    param,
    NONEMPTY_MIN_LENGTH,
    errors.codes.ERROR_CODE_INVALID_PASSWORD,
  );
}

function validateOptionalPassword(param) {
  // Password is optional so skip validation if undefined
  if (param === undefined) {
    return;
  }

  // Otherwise password must be non-empty string
  validatePassword(param);
}


function validatePasswordId(param) {
  // Password ID should have been generated by IDS
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_PASSWORD_ID,
  );
  validRegex(
    param,
    `^${regex.UDS_ID_REGEX}$`,
    errors.codes.ERROR_CODE_INVALID_PASSWORD_ID,
  );
}

function validateAppRealm(param) {
  // Check that param matches a known whitelist of realms
  if (!system.realms.apps.includes(param)) {
    throw errors.codes.ERROR_CODE_INVALID_APP_REALM;
  }
}

function validateUserRealm(param) {
  // Check that param matches a known whitelist of realms
  if (!system.realms.users.includes(param)) {
    throw errors.codes.ERROR_CODE_INVALID_USER_REALM;
  }
}

function validateURL(param) {
  // TODOBT - Add some kind of URL validation regex

  // URL should just be a nonempty string for now
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_URL,
  );
  validMinLength(
    param,
    NONEMPTY_MIN_LENGTH,
    errors.codes.ERROR_CODE_INVALID_URL,
  );
}

function validateUser(param) {
  // User ID should be a nonempty string initially
  //  Handler will confirm the User ID exists and is valid
  validMinLength(
    param,
    NONEMPTY_MIN_LENGTH,
    errors.codes.ERROR_CODE_INVALID_USER,
  );
}

function validateOptionalUser(param) {
  // User may be optional so skip validation if undefined
  if (param === undefined) {
    return;
  }

  // Otherwise must be a valid non-empty string
  validateUser(param);
}

function validateApp(param) {
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_APP,
  );
  validRegex(
    param,
    `^${regex.NAME_REGEX}$`,
    errors.codes.ERROR_CODE_INVALID_APP,
  );
}

function validateKey(param) {
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_KEY,
  );
  validRegex(
    param,
    `^${regex.NAME_REGEX}$`,
    errors.codes.ERROR_CODE_INVALID_KEY,
  );
}

function validateAuthz(param) {
  // Authz ID should have been generated by IDS
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_AUTHZ,
  );
  validRegex(
    param,
    `^${regex.UDS_ID_REGEX}$`,
    errors.codes.ERROR_CODE_INVALID_AUTHZ,
  );
}

function validateShareId(param) {
  // Shared data ID should have been generated by IDS
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_SHARE_ID,
  );
  validRegex(
    param,
    `^${regex.UDS_ID_REGEX}$`,
    errors.codes.ERROR_CODE_INVALID_SHARE_ID,
  );
}

function validateCtx(param) {
  validMinLength(
    param,
    NONEMPTY_MIN_LENGTH,
    errors.codes.ERROR_CODE_INVALID_CTX,
  );
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_CTX,
  );
}

function validateType(param) {
  // Check that param matches a known whitelist of data types
  if (!system.types.includes(param)) {
    throw errors.codes.ERROR_CODE_INVALID_DATA_TYPE;
  }
}

export default {
  validateApp,
  validateAppRealm,
  validateAuthz,
  validateCtx,
  validateKey,
  validateName,
  validateOptionalPassword,
  validateOptionalUser,
  validatePassword,
  validatePasswordId,
  validateShareId,
  validateType,
  validateURL,
  validateUser,
  validateUserRealm,
};
