import errors from '../../models/errors';
import regex from '../utils/regex';
import system from '../../models/system';
import constants from '../../utils/constants';

const NONEMPTY_MIN_LENGTH = 1;
const DEFAULT_MAX_LENGTH = 255;

// Helper function to validate a string against a specific regex
function validRegex(value, regexString, errorCode) {
  const requiredRegex = new RegExp(regexString);
  if (requiredRegex.test(value) === false) {
    throw errorCode;
  }
}

// Helper function to validate string length is greater/equal to some min
function validMinLength(value, length, errorCode) {
  if (value.length < length) {
    throw errorCode;
  }
}

// Helper function to validate string length is less/equal to some max
function validMaxLength(value, length, errorCode) {
  if (value.length > length) {
    throw errorCode;
  }
}


// Validate incoming `param` is a string and valid setting name
//  Setting names have a strict regex of allowed characters
function validateName(param) {
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_NAME,
  );
  validRegex(
    param,
    `^${regex.NAME_REGEX}$`,
    errors.codes.ERROR_CODE_INVALID_NAME,
  );
}

function validateURL(param) {
  // TODO - Add some kind of URL validation regex

  // URL should just be a nonempty string for now
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_URL,
  );
  validMinLength(
    param,
    NONEMPTY_MIN_LENGTH,
    errors.codes.ERROR_CODE_INVALID_URL,
  );
}

function validateUser(param) {
  // User ID should be a nonempty string initially
  //  Handler will confirm the User ID exists and is valid
  validMinLength(
    param,
    NONEMPTY_MIN_LENGTH,
    errors.codes.ERROR_CODE_INVALID_USER,
  );
}

function validateOptionalUser(param) {
  // User may be optional so skip validation if undefined
  if (param === undefined) {
    return;
  }

  // Otherwise must be a valid non-empty string
  validateUser(param);
}

function validateApp(param) {
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_APP,
  );
  validRegex(
    param,
    `^${regex.NAME_REGEX}$`,
    errors.codes.ERROR_CODE_INVALID_APP,
  );

  // Cannot be HMH_APP
  if (param === constants.HMH_APP) {
    throw errors.codes.ERROR_CODE_INVALID_APP;
  }
}

function validateKey(param) {
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_KEY,
  );
  validRegex(
    param,
    `^${regex.NAME_REGEX}$`,
    errors.codes.ERROR_CODE_INVALID_KEY,
  );
}

function validateAuthz(param) {
  // Authz name is provided by client
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_AUTHZ,
  );
  validRegex(
    param,
    `^${regex.NAME_REGEX}$`,
    errors.codes.ERROR_CODE_INVALID_AUTHZ,
  );
}

function validateShareId(param) {
  // Shared data ID should have been generated by UDS
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_SHARE_ID,
  );
  validRegex(
    param,
    `^${regex.UDS_UUID_REGEX}$`,
    errors.codes.ERROR_CODE_INVALID_SHARE_ID,
  );
}

function validateCtx(param) {
  validMinLength(
    param,
    NONEMPTY_MIN_LENGTH,
    errors.codes.ERROR_CODE_INVALID_CTX,
  );
  validMaxLength(
    param,
    DEFAULT_MAX_LENGTH,
    errors.codes.ERROR_CODE_INVALID_CTX,
  );
}

function validateType(param) {
  // Check that param matches a known whitelist of data types
  if (!system.types[param]) {
    throw errors.codes.ERROR_CODE_INVALID_DATA_TYPE;
  }
}

export default {
  validateApp,
  validateAuthz,
  validateCtx,
  validateKey,
  validateName,
  validateOptionalUser,
  validateShareId,
  validateType,
  validateURL,
  validateUser,
};
