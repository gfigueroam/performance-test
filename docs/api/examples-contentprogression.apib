FORMAT: 1A

# Content Progression

[scenario source](https://hmhco.slack.com/files/U07CMCTU1/F6SHY9X08/user-centric-content.pdf)

As a user reads content, page turn events are emitted to Apache Spark. When the Apache Spark worker detects an abnormally long pause between page turn events, it will assume the reader has stopped reading and will emit a message to UDS on the UDS Calculated Behavior Kafka queue.

## UDS Calculated Behavior Kafka Messages
Each UDS Calculated Behavior message will have:
* `user` - the user affected by this message
* `key` - the key to use for this message
* `operation` - the operation to perform. One of: `increment`, `decrement`, `merge`, `set`.
* `value` - the value to use for `merge` and `set` operations.

## Processing Content Progression Events
 UDS will have a kafka consumer listening for these events which will call the appropriate API, `data.cb.<operation>`. UDS models all content progression as a single object. This object has a key for each contentID that the user has stored some content progression, and the value of each key will be coordinates of the user's progression through the content (and any other desired metadata, such as a mastery score). To update or store content progression, the UDS kafka message's operation will be `merge`, and the UDS API call will be:

  `uds.data.cb.merge(user: <user>, key: "contentProgression", object: {"contentIdXYZ": {"coords": {"page": 120}}})`

When a user first stores content progression, they will not have a value for the `contentProgression` key; however the merge operation will behave as though the pre-existing value is `{}` and the resulting content progression will be

```
{
  "contentIdXYZ": {
    "coords": {
      "page": 120
    }
  }
}
```

If the user then proceeds to read to page 32 of contentIdABC, the spark worker will emit the following message to UDS:
```
user: <user>,
key: "contentProgression",
operation: "merge",
value: {"contentIdABC": {"coords": {"page": 32}}}
```

The UDS Kafka consumer will then place the following call to the UDS API:

  `uds.data.cb.merge(user: <user>, key: "contentProgression", object: {"contentIdABC": {"coords": {"page": 32}}})`

The resulting content progression will be

```
{
  "contentIdXYZ": {
    "coords": {
      "page": 120
    }
  },
  "contentIdABC": {
    "coords": {
      "page": 32
    }
  }
}
```

## Querying A User's Content Progression
Simply get the current contentProgression value and access the relevant content ID:

```
  const contentProgression = await uds.data.cb.get(user: <user>, key: "contentProgression");
  const currentPage = contentProgression.contentIdABC.coords.page
```

## Content Progression Object Size
It is technically possible for the object stored under the `contentProgression` key to grow very large. However, assuming a learner goes from K-12 reading (and thus storing content progression for) 100 books per year, we believe the total size of the object will be 13 * 100 = 1,300 records, which is a reasonable size to use as an upper-bound. (In all likelihood the average content progression size may be much smaller: if a learner uses 10 textbooks per year, then this would be only a 130-key object.) Potential future UDS API enhancements could allow for a GraphQL query to return a subset of the content progression object if necessary.
